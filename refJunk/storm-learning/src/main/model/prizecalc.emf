@namespace(uri="http://info.jchein/ECORE+Crossword+Storm+Topology+Messages/EN/0.0.1", prefix="pcalc")
@genmodel(basePackage="info.jchein.sandbox.app.crossword.prizecalc")
package prizecalc;

import "http://info.jchein/ECORE+Crossword+Resource+Representations/EN/0.0.1";

class AsyncPrizeAnalysisRequest {
	id attr String ticketHref;
	ref xw.RevealedInformation revealedInfo;
	ref xw.BoardCoverage boardCoverage;
}

class AsyncPrizeAnalysisResponse {
}

class ReportPrizeAnalysisRequest {
	ref xw.PrizeAnalysis prizeAnalysis;
}

class ReportPrizeAnalysisResponse {
}


datatype BitSet : java.util.BitSet;

class AvailableLetter {
	attr char[1] letter;
	attr BitSet[1] wordHitMask;
}

@ecore(documentation="A rearrangement of the reusable information from Task input, optimized for the analysis task.")
class TicketState {
	@ecore(documentation="If the bonus word has been covered, this value will be -1.  Otherwise, it will be the index of both incompleteWords and wordHit BitMask that represents the bonus word.")
	attr int bonusWordIndex;
	@ecore(documentation="If true, at least one tripling word has already been covered.  If false, then the incomplete words at indices 0..3 are qualifiers for the triple bonus")
	attr boolean tripled;
	@ecore(documentation="The number of crossword grid words already covered and therefore excluded from incompleteWords and the wordHit BitMask")
	attr int wordsCompleted;
	@ecore(documentation="Each array value gives the number of unique letters remaining to cover an incomplete word.  For each AvailableLetter in the availableLetters property that corresponds to one of those missing letters, that object's wordHit BitMask has a bit set at the same index.")
	ordered attr int[13..23] incompleteWords;
	@ecore(documentation="A collection of objects representing the unique letters not yet uncovered and an associated BitMask selecting the indices of wordsCompleted that represent words that need the associated letter.")
	unique ordered val AvailableLetter[9..26] availableLetters;	
}

class BeginCalculation {
	attr String ticketHref;
	ref TicketState ticketState;
}

class SubtaskRequest {
	id attr String subTaskId;
	attr String taskId;
	attr String ticketHref;
	ref TicketState ticketState;
	attr int[11..28] pStateInit;
	attr int maxPermutes;
}

class SubtaskResponse {
	id attr String subTaskId;
	attr String taskId;
	attr String ticketHref;
	attr int[18] prizeDistribution;
}

class TaskResult {
    id attr String taskId;
    attr String ticketHref;
	ref xw.PrizeAnalysis report;
}
