
<cellEditor cellModel="scope.property" cursorModel="scope.property" signalModel="scope.property" cellOrg="1D,Rows,Cols|1D,Cols,Rows|2D,Rows,Cols|2D,Cols,Rows" cellSize="WxH" cellCount="NxM" gridSize="WxH">
    <keyInputExpr expr="callback for expr(cursorCell, kb event)" bind-to="scope read for key bindings" is-active="alternate deactivator">
    <keyInputExpr expr="callback expression" bind-to="key bindings">
    <mouseClickExpr expr="callback expression"></mouseClickExpr>
    <cellImageLayer altitude="z" imageHash="{key: uri, key:uri, key:uri}" keyExpr="readonly cell expr"></cellImageLayer>
</cellEditor>

-- Interpolation is not supported to make any part of the above dynamic
-- Each cell may use image layers may use one or none of the available images for each of its image layers.
-- cellModel array is instantiated by directive consumer.  It is a 1D or a 2D array.  Cells are arranged in either column-first or row-first ordering.
   -- The order of cells in the grid is given by the "gridCellOrder" property.  If omitted, 2D, row-first organization is the presumed default.
   -- In each of these four possibilities, cell (x,y) on screen comes from:
      -- For a 1D row-first ordering, the cell with index = ((x*numCols) + y)              "1D,RowCol"
      -- For a 1D col-first ordering, the cell with index = (x + (y*numRows))              "1D,ColRow"
      -- For a 2D row-first ordering, the cell at coordinates [x][y]                       "2D,RowCol"  **Default**
      -- For a 2D col-first ordering, the cell at coordiantes [y][x]                       "2D,ColRow"
-- Of the three remaining attributes, only two must be provided.  The third can be inferred from the other two.  It is also valid to provide all three
   attributes, provided they are consistent with one another.
   -- gridSize gives the width and height of the grid, essenetialy the sum across all cells.  Format: "<<Width>> x <<Height>>"
      Examples: "640x480  ", "400 x 300", " 768  x   768"
   -- cellSize gives the width and height of each cell in pixels.  Format is (whitespace optional):  "<<Width>> x <<Height>>"
      Examples: "28 x 28", "100x100", "40x 60"
   -- cellCount gives the number of cells horizontally, then vertically.  Format (whitespace optional): "<<CellsPerRow>> x <<CellsPerColumn>>"
      Examples: "11 x 11", "64x48", and "6 x1"
-- cellEditor, despite its name, does NOT change state directly.  It does fire behavioral callbacks as configured, and it propagates observed changes, whether
   or not they occur during its own callbacks, provided they occur in an angular $apply/$digest cycle.
-- If numRows * numCols != cellModel.length() (or the product of its two dimensions if 2D), cellEditor will fail during HTML compilation.  Neither the
   size of cellModel nor the sizing properties passed to cellEditor may change during its lifespan.

MODELS
-- gridModel and cellModel are a model of the directive consumer's application state.  The former is a single object representing the grid as a whole, the latter
   is either a 1D array or a 2D array with one object for each cell in the compiled grid.

-- cursorModel is
   {  isActive: boolean,
      xPos: non-negative integer, range 0..numRows-1
      yPos: non-negative integer, range 0..numCols-1 }
   -- xPos and yPos only have meaning when isActive is true.  In that case, they identify the location of the active cell editor's cursor.  The cursor
      cell is an available argument when resolving key bindings for input expressions and the on-key expressions they trigger.
   -- A cell's coordinates are provided with mouse click expressions too, but these identify the location of a click that may have no relationship to
      the currently active cursor, if any.  Mouse clicks are often used by a consumer to set the location of a cursor by assigning their values to the
      cursorModel's xPos/yPos attributes and flipping its isActive state to true, if necessary.

SIGNAL EXPRESSIONS
-- If the number of cells is large in relation to the frequency of state changes (which is give as an indirect measure of watch overhead efficiency--bang
   for your proverbial buck) then cell-wise watch registration by cellEditor is excessive.  By default, ModelEditor aims to reduce propagation delay by watching
   the expression given for each image layer's lookup key expression directly one time for each cell, using a scope per cell to target each watch registration.
   from a scope focused.  This behaviour can be overridden in two different ways:
   -- The cellEditor directive also supports a non-mandatory "options" attribute, a comma-separated list of camelCased key-value pairs.  Two options can
      be applied here.
      -- 'mergeImageLayerWatches=true' : CellEditor will create a one watch expression for all image layers per cell, instead of one watch expression per
         layer per cell.
      -- 'watchGridNotCells=true'
      If any of the layers in a cell change, the handle will trigger and all layers will be refreshed from their lookup key expressions.  Use this mode
      if the overhead of redundant image lookups is outclassed by the savings of

-- TBD: Handling loss of focus to other DOM elements beyond cellEditor's control
-- TBD: Participating with ngModel for the sake of manipulating form activation states



